stages:
  - build
  - test
  - deploy

build:
  stage: build
  image: docker:latest
  services:
    - docker:dind
  script:
    - docker build -t afjalbetsilah/wordlife:latest .
    - docker tag afjalbetsilah/wordlife:latest $CI_REGISTRY_IMAGE:latest
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
    - docker push $CI_REGISTRY_IMAGE:latest

test:
  stage: test
  image: node:20
  script:
    - npm install

deploy:
  stage: deploy
  image: alpine/k8s:1.31.4
  script:
    - echo "$KUBE_CONFIG" > kubeconfig.yaml
    - export KUBECONFIG=kubeconfig.yaml
    # Installer AWS CLI
    - apk add --no-cache aws-cli
    # Configurer AWS CLI
    - aws configure set aws_access_key_id "$AWS_ACCESS_KEY_ID"
    - aws configure set aws_secret_access_key "$AWS_SECRET_ACCESS_KEY"
    - aws configure set region "$AWS_DEFAULT_REGION"
    # Vérifier l'identité AWS
    - aws sts get-caller-identity
    # Vérifier la connectivité EKS
    - aws eks --region "$AWS_DEFAULT_REGION" update-kubeconfig --name mind
    - kubectl version
    - kubectl get nodes
    # Vérifier si l'image Docker est bien poussée
    - docker pull afjalbetsilah/wordlife:$CI_COMMIT_SHA || echo "Image non disponible !"
    # Appliquer les fichiers Kubernetes
    - kubectl apply -f kubernets
    # Vérifier les pods
    - kubectl get pods -o wide
    - kubectl describe pod -l app=wordlife-deployements
    - kubectl logs -l app=wordlife-deployements || echo "Pas encore de logs, peut-être en création..."
    # Redémarrer les pods si nécessaire
    - kubectl delete pod -l app=wordlife-deployements || true
    # Vérifier l'état du déploiement
    - kubectl set image deployment/deployement-wl wordlife-container=afjalbetsilah/wordlife:$CI_COMMIT_SHA
    - kubectl get services


    